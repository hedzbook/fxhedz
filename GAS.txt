// ======================================================
// CONFIG
// ======================================================
const TOKEN = PropertiesService.getScriptProperties().getProperty("BOT_TOKEN");
const WEBHOOK_SECRET = PropertiesService.getScriptProperties().getProperty("WEBHOOK_SECRET");
const SPREADSHEET_ID = "1jMlONsIzwXyf_j9y96HkeIwRh0OynfTUak3MvHrJLyo";
const SHEET_NAME = "USERS_AUTH";
const ADMIN_CHAT_ID = "7115081072";

const PAIRS = [
    "ETHUSD",
    "USDCHF",
    "USDJPY",
    "XAUUSD",
    "EURUSD",
    "GBPUSD",
    "AUDUSD",
    "USOIL",
    "BTCUSD"
];

// ==========================================
// COLUMN INDEX MAP (0-based)
// ==========================================
const COL = {
    email: 0,
    created_at: 1,
    expiry: 2,
    plan: 3,
    plan_months: 4,

    telegram_pairs: 5,
    telegram_chat_id: 6,

    android_pairs: 7,
    android_push_token: 8,

    web_pairs: 9,
    web_push_token: 10,

    platform: 11,
    play_purchase_token: 12,
    refresh_token_hash: 13,
    refresh_token_expiry: 14
};

function getPairPerformanceCache() {
    const raw = PropertiesService
        .getScriptProperties()
        .getProperty("PAIR_PERFORMANCE")
    return raw ? JSON.parse(raw) : {}
}

function setPairPerformanceCache(data) {
    PropertiesService
        .getScriptProperties()
        .setProperty("PAIR_PERFORMANCE", JSON.stringify(data))
}

function getLiveSignals() {
    const raw = PropertiesService
        .getScriptProperties()
        .getProperty("LIVE_SIGNALS");

    let data = raw ? JSON.parse(raw) : {};

    // üî• AUTO-CLEAN INVALID KEYS
    Object.keys(data).forEach(k => {
        const key = (k || "").toUpperCase().trim();
        if (PAIRS.indexOf(key) === -1) {
            delete data[k];
        }
    });

    return data;
}

function setLiveSignals(data) {

    const safe = {};

    // Rebuild strictly from approved PAIRS list
    PAIRS.forEach(pair => {

        if (!data[pair]) return;

        safe[pair] = {
            direction: data[pair].direction || null,
            entry: data[pair].entry || null,
            sl: data[pair].sl || null,
            tp: data[pair].tp || null,
            price: data[pair].price || null,
            lots: Number(data[pair].lots || 0),
            buys: Number(data[pair].buys || 0),
            sells: Number(data[pair].sells || 0),
            candles: Array.isArray(data[pair].candles) ?
                data[pair].candles.slice(-60) : [],
            orders: Array.isArray(data[pair].orders) ?
                data[pair].orders.slice(0, 20) : []
        };
    });

    const json = JSON.stringify(safe);

    // üîí Hard memory guard (~100 KB safe ceiling)
    if (json.length > 90000) {
        Logger.log("LIVE_SIGNALS too large, skipping write");
        return;
    }

    PropertiesService
        .getScriptProperties()
        .setProperty("LIVE_SIGNALS", json);
}

function getOrderHistory() {
    const raw = PropertiesService
        .getScriptProperties()
        .getProperty("ORDER_HISTORY")
    return raw ? JSON.parse(raw) : {}
}

function setOrderHistory(data) {
    PropertiesService
        .getScriptProperties()
        .setProperty("ORDER_HISTORY", JSON.stringify(data))
}

function appendHistoryRow(instrument, direction, entry, exit, pnl, time) {

    const sheet = SpreadsheetApp.openById(SPREADSHEET_ID)
        .getSheetByName("ORDER_HISTORY")

    sheet.appendRow([
        time,
        instrument,
        direction,
        entry,
        exit,
        pnl
    ])
}

function getMarketNotes() {
    const raw = PropertiesService
        .getScriptProperties()
        .getProperty("MARKET_NOTES")
    return raw ? JSON.parse(raw) : {}
}

function setMarketNotes(data) {
    PropertiesService
        .getScriptProperties()
        .setProperty("MARKET_NOTES", JSON.stringify(data))
}

function handleAuthUser(email, deviceId, fingerprint, platform, telegramChatId, refreshHash, refreshExpires) {

    if (!email) {
        return {
            active: false,
            plan: null,
            expiry: null
        };
    }

    email = String(email).toLowerCase().trim();

    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    for (let i = 1; i < rows.length; i++) {

        if (String(rows[i][COL.email] || "").toLowerCase() !== email) continue;

        // üî• FIX: Update telegram_chat_id if missing or changed
        if (telegramChatId) {

            const currentChatId = String(rows[i][COL.telegram_chat_id] || "");

            if (!currentChatId || currentChatId !== telegramChatId) {

                sheet.getRange(i + 1, COL.telegram_chat_id + 1)
                    .setValue(telegramChatId);
            }
        }

        // SAVE REFRESH HASH + EXPIRY (Columns M & N)
        if (refreshHash) {
            sheet.getRange(i + 1, COL.refresh_token_hash + 1)
                .setValue(refreshHash);
        }

        if (refreshExpires) {
            sheet.getRange(i + 1, COL.refresh_token_expiry + 1)
                .setValue(refreshExpires);
        }

        const expiry = rows[i][COL.expiry] ?
            new Date(rows[i][COL.expiry]) :
            null;
        const plan = String(rows[i][COL.plan] || "").toLowerCase();

        const isLivePlusActive =
            plan === "live+" &&
            expiry &&
            expiry > now;

        return {
            active: plan === "live" || isLivePlusActive,
            plan: isLivePlusActive ? "live+" : "live",
            expiry: expiry || null
        };
    }

    // =========================
    // NEW USER ‚Üí BASE TIER
    // =========================

    sheet.appendRow([
        email, // A
        now, // B
        "", // C expiry
        "live", // D plan
        0, // E plan_months

        "", // F telegram_pairs
        telegramChatId || "", // G telegram_chat_id

        "", // H android_pairs
        "", // I android_push_token

        "", // J web_pairs
        "", // K web_push_token

        platform || "web", // L platform
        "", // M play_purchase_token
        refreshHash || "", // N refresh_token_hash
        refreshExpires || "" // O refresh_token_expiry
    ]);

    return {
        active: true,
        plan: "live"
    };
}

function checkAuthUser(email) {

    if (!email) return {
        active: false
    };

    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    email = email.toLowerCase().trim();

    for (let i = 1; i < rows.length; i++) {

        if (String(rows[i][COL.email] || "").toLowerCase() !== email) continue;

        const expiry = rows[i][COL.expiry] ?
            new Date(rows[i][COL.expiry]) :
            null;
        const plan = String(rows[i][COL.plan] || "").toLowerCase();
        const now = new Date();

        const isLivePlusActive =
            plan === "live+" &&
            expiry &&
            expiry > now;

        return {
            active: plan === "live" || isLivePlusActive,
            plan: isLivePlusActive ? "live+" : "live",
            expiry: expiry || null
        };
    }

    return {
        active: false
    };
}

// ======================================================
// SINGLE WEBHOOK ENTRY - WRITE pipeline (MT5 ‚Üí GAS)
// ======================================================
function doPost(e) {
    const ack = ok();

    try {
        if (!e || !e.postData || !e.postData.contents) return ack;
        // ===============================
        // GOOGLE AUTH SYNC
        // ===============================
        const contentType = e.postData.type || "";

        if (contentType.indexOf("application/json") !== -1) {

            const data = JSON.parse(e.postData.contents);

            // ===============================
            // ANDROID BILLING
            // ===============================
            if (data.purchase_token && data.email && data.platform === "android") {

                const result = activateAndroidPurchase(
                    data.email,
                    data.purchase_token,
                    data.months || 1
                );

                return ContentService
                    .createTextOutput(JSON.stringify(result))
                    .setMimeType(ContentService.MimeType.JSON);
            }

            // ===============================
            // APP INSTRUMENT UPDATE
            // ===============================
            if (data.app_instruments && data.email) {

                const sheet = mustGetSheet();
                const rows = sheet.getDataRange().getValues();

                for (let i = 1; i < rows.length; i++) {

                    if (String(rows[i][0] || "").toLowerCase() !== data.email.toLowerCase())
                        continue;

                    // Column H = index 7
                    sheet.getRange(i + 1, COL.android_pairs + 1).setValue(
                        data.app_instruments.join(",")
                    );

                    return ContentService
                        .createTextOutput(JSON.stringify({
                            success: true
                        }))
                        .setMimeType(ContentService.MimeType.JSON);
                }
            }

            // ===============================
            // SAVE PUSH TOKEN
            // ===============================
            if (data.push_token && data.email) {

                const sheet = mustGetSheet();
                const rows = sheet.getDataRange().getValues();

                for (let i = 1; i < rows.length; i++) {

                    if (String(rows[i][0] || "").toLowerCase() !== data.email.toLowerCase())
                        continue;

                    sheet.getRange(i + 1, COL.android_push_token + 1).setValue(data.push_token);

                    return ContentService
                        .createTextOutput(JSON.stringify({
                            success: true
                        }))
                        .setMimeType(ContentService.MimeType.JSON);
                }
            }

            // ===============================
            // TELEGRAM MINI APP INSTRUMENT UPDATE (BY EMAIL)
            // ===============================
            if (data.telegram_instruments && data.email) {

                const sheet = mustGetSheet();
                const rows = sheet.getDataRange().getValues();

                for (let i = 1; i < rows.length; i++) {

                    const rowEmail =
                        String(rows[i][COL.email] || "").toLowerCase().trim();

                    if (rowEmail !== data.email.toLowerCase().trim())
                        continue;

                    sheet.getRange(i + 1, COL.telegram_pairs + 1)
                        .setValue(data.telegram_instruments.join(","));

                    return ContentService
                        .createTextOutput(JSON.stringify({
                            success: true
                        }))
                        .setMimeType(ContentService.MimeType.JSON);
                }
            }

            if (data.web_instruments && data.email) {

                const sheet = mustGetSheet();
                const rows = sheet.getDataRange().getValues();

                for (let i = 1; i < rows.length; i++) {

                    if (String(rows[i][COL.email] || "").toLowerCase() !== data.email.toLowerCase())
                        continue;

                    sheet.getRange(i + 1, COL.web_pairs + 1)
                        .setValue(data.web_instruments.join(","));

                    return ContentService
                        .createTextOutput(JSON.stringify({
                            success: true
                        }))
                        .setMimeType(ContentService.MimeType.JSON);
                }
            }

            if (data.web_push_token && data.email) {

                const sheet = mustGetSheet();
                const rows = sheet.getDataRange().getValues();

                for (let i = 1; i < rows.length; i++) {

                    if (String(rows[i][COL.email] || "").toLowerCase() !== data.email.toLowerCase())
                        continue;

                    sheet.getRange(i + 1, COL.web_push_token + 1)
                        .setValue(data.web_push_token);

                    return ContentService
                        .createTextOutput(JSON.stringify({
                            success: true
                        }))
                        .setMimeType(ContentService.MimeType.JSON);
                }
            }

            // ===============================
            // REFRESH TOKEN VALIDATION
            // ===============================
            if (data.refresh_validate && data.email) {

                const result = validateRefreshToken(
                    data.email,
                    data.device_id || "",
                    data.refresh_token_hash || ""
                );

                return ContentService
                    .createTextOutput(JSON.stringify(result))
                    .setMimeType(ContentService.MimeType.JSON);
            }

            // ===============================
            // APP LOGIN
            // ===============================
            if (data.email && !data.refresh_validate) {

                const result = handleAuthUser(
                    data.email,
                    data.device_id || "",
                    data.fingerprint || "",
                    data.platform || "web",
                    data.telegram_chat_id || "",
                    data.refresh_token_hash || "",
                    data.refresh_expires || ""
                );

                return ContentService
                    .createTextOutput(JSON.stringify(result))
                    .setMimeType(ContentService.MimeType.JSON);
            }
        }

        const type = e.postData.type || "";

        // ==================================================
        // TELEGRAM (JSON)
        // ==================================================
        if (type.indexOf("application/json") !== -1) {
            const data = JSON.parse(e.postData.contents);
            handleTelegram(data);
            return ack;
        }

        // ==================================================
        // MT5 SCREENSHOT (RAW BINARY) ‚Äî MUST COME FIRST
        // ==================================================
        if (
            type.indexOf("application/json") === -1 &&
            type.indexOf("application/x-www-form-urlencoded") === -1
        ) {
            const secret = (e.parameter && e.parameter.secret || "").trim();
            if (secret !== WEBHOOK_SECRET) return ack;

            // üîë THE FIX ‚Äî binary-safe read
            const bytes = e.postData.getBytes();
            if (!bytes || bytes.length < 2000) return ack;

            const blob = Utilities.newBlob(
                bytes,
                "image/jpeg",
                "chart.jpg"
            );

            const tx = (e.parameter && e.parameter.tx) || "";
            dispatchImageToUsers(blob, tx);

            return ack; // ‚õî DO NOT FALL THROUGH
        }

        // ==================================================
        // MT5 TEXT ALERT (FORM URLENCODED)
        // ==================================================
        const params = {};
        e.postData.contents.split("&").forEach(p => {
            const idx = p.indexOf("=");
            if (idx === -1) return;
            const k = decodeURIComponent(p.substring(0, idx));
            const v = decodeURIComponent(p.substring(idx + 1));
            params[k] = v;
        });

        if ((params.secret || "").trim() !== WEBHOOK_SECRET) return ack;

        // ============================
        // MARKET NOTES UPDATE (ADD HERE)
        // ============================
        if (params.notes) {
            updateMarketNotes(params.notes);
            return ack;
        }

        // normal signal flow
        if (!params.message) return ack;

        handleSignal(params.message.trim(), params.tx);

        return ack;

    } catch (err) {
        send(ADMIN_CHAT_ID, "‚ùå GAS ERROR\n<code>" + err + "</code>");
        return ack;
    }
}

function validateRefreshToken(email, deviceId, refreshHash) {

    if (!email || !refreshHash) {
        return {
            valid: false
        };
    }

    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    email = String(email).toLowerCase().trim();

    for (let i = 1; i < rows.length; i++) {

        const rowEmail = String(rows[i][COL.email] || "").toLowerCase().trim();
        if (rowEmail !== email) continue;

        const storedHash = String(rows[i][COL.refresh_token_hash] || "");
        const storedExpiry = rows[i][COL.refresh_token_expiry] ?
            new Date(rows[i][COL.refresh_token_expiry]) :
            null;

        if (!storedHash || storedHash !== refreshHash) {
            return {
                valid: false
            };
        }

        if (!storedExpiry || storedExpiry < now) {
            return {
                valid: false
            };
        }

        return {
            valid: true
        };
    }

    return {
        valid: false
    };
}

function requireSignalAccess(email) {

    const auth = checkAuthUser(email);

    if (!auth || !auth.active) {
        return {
            blocked: true,
            plan: auth ? auth.plan : "none"
        };
    }

    return {
        blocked: false,
        plan: auth.plan
    };
}

// ======================================================
// READ pipeline  (WebApp ‚Üí GAS)
// ======================================================

function doGet(e) {

    // =========================================
    // IMAGE PROXY (Drive ‚Üí Direct Binary)
    // =========================================
    if (e.parameter.image) {
        try {

            const fileId = String(e.parameter.image).trim();
            const file = DriveApp.getFileById(fileId);
            const blob = file.getBlob();

            const base64 = Utilities.base64Encode(blob.getBytes());
            const mime = blob.getContentType() || "image/jpeg";

            const html = `
            <html>
              <body style="margin:0;padding:0;background:#000;">
                <img src="data:${mime};base64,${base64}" 
                     style="width:100%;height:auto;display:block;" />
              </body>
            </html>
        `;

            return HtmlService.createHtmlOutput(html)
                .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);

        } catch (err) {

            return ContentService
                .createTextOutput("image_error:\n" + err)
                .setMimeType(ContentService.MimeType.TEXT);
        }
    }
    // ================= AUTH SECTION BELOW (unchanged) =================
    const secret = (e.parameter.secret || "").trim();
    if (secret !== WEBHOOK_SECRET) {
        return ContentService
            .createTextOutput("unauthorized")
            .setMimeType(ContentService.MimeType.TEXT);
    }

    const email = (e.parameter.email || "").toLowerCase().trim();
    const pair = (e.parameter.pair || "").toUpperCase();

    if (!email) return jsonBlocked("none");

    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();

    for (let i = 1; i < rows.length; i++) {

        const rowEmail = String(rows[i][COL.email] || "").toLowerCase().trim();
        if (rowEmail !== email) continue;

        const rawPlan = String(rows[i][COL.plan] || "").toLowerCase();
        const expiry = rows[i][COL.expiry] ?
            new Date(rows[i][COL.expiry]) :
            null;
        const now = new Date();

        const isLivePlusActive =
            rawPlan === "live+" &&
            expiry &&
            expiry > now;

        const finalPlan = isLivePlusActive ? "live+" : "live";

        if (finalPlan !== "live" && finalPlan !== "live+") {
            return jsonBlocked(finalPlan);
        }

        return buildSignalResponse({
            plan: finalPlan,
            expiry: expiry || null
        }, pair, email);
    }

    return jsonBlocked("none");
}

function jsonBlocked(plan) {
    return ContentService
        .createTextOutput(JSON.stringify({
            blocked: true,
            active: false,
            plan: plan || null,
            signals: {}
        }))
        .setMimeType(ContentService.MimeType.JSON);
}

function buildSignalResponse(access, pair, email) {

    let signals = getLiveSignals();

    // =========================================
    // PLAN BASED FILTERING
    // =========================================

    if (access.plan === "live") {

        const allowed = ["ETHUSD", "USDCHF"];
        const filtered = {};

        Object.keys(signals).forEach(p => {
            if (allowed.indexOf(p) !== -1) {
                filtered[p] = signals[p];
            }
        });

        signals = filtered;

    } else if (access.plan !== "live+") {
        // Anything other than live or live+ is blocked
        return jsonBlocked(access.plan);
    }

    // =========================================
    // PAIR SPECIFIC REQUEST
    // =========================================

    if (pair && access.plan === "live") {
        const allowed = ["ETHUSD", "USDCHF"];
        if (allowed.indexOf(pair) === -1) {
            return jsonBlocked(access.plan);
        }
    }
    if (pair) {

        const data = getPairDataFromSheet(pair);
        const notes = getMarketNotes();
        const orders = signals[pair]?.orders || [];

        const feedSheet = SpreadsheetApp
            .openById(SPREADSHEET_ID)
            .getSheetByName("UPDATES_FEED");

        const rowsFeed = feedSheet.getDataRange().getValues();
        const feed = [];

        for (let i = rowsFeed.length - 1; i > 0; i--) {

            if (rowsFeed[i][1] !== pair) continue;

            feed.push({
                time: rowsFeed[i][0],
                pair: rowsFeed[i][1],
                text: rowsFeed[i][2],
                image: rowsFeed[i][3],
                source: rowsFeed[i][4]
            });

            if (feed.length >= 50) break;
        }

        const sheet = mustGetSheet();
        const rows = sheet.getDataRange().getValues();

        // =========================================
        // PLATFORM AWARE INSTRUMENT LOAD
        // =========================================

        let appInstruments = [];
        let webInstruments = [];
        let telegramInstruments = [];

        for (let i = 1; i < rows.length; i++) {

            const rowEmail = String(rows[i][COL.email] || "").toLowerCase().trim();

            if (rowEmail !== email) continue;

            if (rows[i][COL.android_pairs]) {
                appInstruments = String(rows[i][COL.android_pairs])
                    .split(",")
                    .filter(Boolean);
            }

            if (rows[i][COL.web_pairs]) {
                webInstruments = String(rows[i][COL.web_pairs])
                    .split(",")
                    .filter(Boolean);
            }

            if (rows[i][COL.telegram_pairs]) {
                telegramInstruments = String(rows[i][COL.telegram_pairs])
                    .split(",")
                    .filter(Boolean);
            }

            break;
        }

        return ContentService
            .createTextOutput(JSON.stringify({
                blocked: false,
                active: true,
                plan: access.plan,
                expiry: access.expiry || null,
                signals,
                history: data.history,
                performance: data.performance,
                notes: notes[pair] || "",
                orders,
                feed,
                appInstruments,
                webInstruments,
                telegramInstruments
            }))
            .setMimeType(ContentService.MimeType.JSON);
    }

    // =========================================
    // GENERAL REQUEST
    // =========================================

    return ContentService
        .createTextOutput(JSON.stringify({
            blocked: false,
            active: true,
            plan: access.plan,
            expiry: access.expiry || null,
            signals
        }))
        .setMimeType(ContentService.MimeType.JSON);
}

// ======================================================
// TELEGRAM HANDLER
// ======================================================
function handleTelegram(data) {

    const cache = CacheService.getScriptCache();

    const updKey = data.update_id ? String(data.update_id) : Utilities.getUuid();
    if (cache.get(updKey)) return;
    cache.put(updKey, "1", 300);

    if (data.callback_query) {
        handleCallback(data.callback_query);
        return;
    }

    if (!data.message || !data.message.text) return;

    const chatId = String(data.message.chat.id);
    const text = data.message.text.trim();
    const from = data.message.from || {};

    // CORE ENTRY
    if (text === "/start") return onStart(chatId, from);

    // OPTIONAL TOOL
    if (text === "/myid") return onMyId(chatId);

    // UI ROUTING (emoji safe)
    if (text) {
        if (text.includes("PAIR")) return onInstruments(chatId);
        if (text.includes("LIVE")) return onSubscription(chatId);
        if (text.includes("READ")) return onBooks(chatId);
        if (text.includes("HELP")) return onSupport(chatId);
    }

    // ADMIN
    if (chatId === ADMIN_CHAT_ID && text.startsWith("/activate")) return onActivate(text);
    if (chatId === ADMIN_CHAT_ID && text.startsWith("/deactivate")) return onDeactivate(text);
    if (chatId === ADMIN_CHAT_ID && text.startsWith("/sendall")) return onBroadcast(text);
    if (chatId === ADMIN_CHAT_ID && text.startsWith("/reply")) return onAdminReply(text);
}

function setBotCommands() {
    const url = "https://api.telegram.org/bot" + TOKEN + "/setMyCommands";

    const payload = {
        commands: [{
                command: "start",
                description: "Open main menu"
            },
            {
                command: "pair",
                description: "Select instruments"
            },
            {
                command: "live",
                description: "View live+ plans"
            },
            {
                command: "read",
                description: "Forex Trilogy Books"
            },
            {
                command: "myid",
                description: "Show your Chat ID"
            },
            {
                command: "help",
                description: "Support & assistance"
            },
        ]
    };

    UrlFetchApp.fetch(url, {
        method: "post",
        contentType: "application/json",
        payload: JSON.stringify(payload)
    });
}

function onInstruments(chatId) {

    const row = getUserRow(chatId);
    const plan = row ? row.plan : "live";

    let selected = getTempInstruments(chatId);

    if (!selected) {
        selected = getUserInstruments(chatId);
        setTempInstruments(chatId, selected);
    }

    // üîí Dynamic Title Based on Plan
    const title =
        plan === "live+" ?
        "üîî <b>Select Trading Instruments</b>\n\nToggle pairs then press Confirm." :
        "üîî <b>Select Trading Instruments</b>\n\nLIVE includes ETHUSD & USDCHF only.";

    sendRich(
        chatId,
        title,
        buildInstrumentKeyboard(selected) // unchanged
    );
}

function buildInstrumentKeyboard(selected) {

    const rows = [];
    let currentRow = [];

    // build 2 buttons per row automatically
    PAIRS.forEach((pair, index) => {

        currentRow.push({
            text: toggleText(pair, selected),
            callback_data: "inst_tmp_" + pair
        });

        if (currentRow.length === 2) {
            rows.push(currentRow);
            currentRow = [];
        }
    });

    // push remaining button if odd count
    if (currentRow.length) rows.push(currentRow);

    // add confirm/cancel row
    rows.push([{
            text: "‚úÖ Confirm",
            callback_data: "inst_confirm"
        },
        {
            text: "‚ùå Cancel",
            callback_data: "inst_cancel"
        }
    ]);

    return {
        inline_keyboard: rows
    };
}

function toggleText(inst, selected) {
    return (selected.indexOf(inst) !== -1 ? "üü¢ " : "‚ö™ ") + inst;
}

function onSignals(chatId) {

    if (!isUserAllowed(chatId)) {
        sendExpired(chatId);
        return;
    }

    send(
        chatId,
        "üìä <b>Open Signals Panel</b>\n\n" +
        "Tap the <b>Menu</b> button below the chat to launch live signals."
    );
}

let _sheet = null;

function mustGetSheet() {
    if (!_sheet) {
        _sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAME);
    }
    return _sheet;
}

function onActivate(text) {

    const parts = text.trim().split(/\s+/);
    if (parts.length < 3) {
        send(ADMIN_CHAT_ID, "Usage: /activate <chatId> <months>");
        return;
    }

    const chatId = parts[1];
    const months = parseInt(parts[2], 10);
    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    for (let i = 1; i < rows.length; i++) {

        if (String(rows[i][COL.telegram_chat_id]) === chatId) {

            const currentExpiry = new Date(rows[i][2]);
            const plan = String(rows[i][3]).toLowerCase();

            const baseDate =
                (plan === "live+" && currentExpiry > now) ?
                currentExpiry :
                now;

            const newExpiry = new Date(baseDate);
            newExpiry.setMonth(newExpiry.getMonth() + months);

            sheet.getRange(i + 1, 3).setValue(newExpiry); // C expiry
            sheet.getRange(i + 1, 4).setValue("live+"); // D plan
            sheet.getRange(i + 1, 5).setValue(months); // E plan_months

            send(chatId,
                "‚úÖ <b>Subscription Activated</b>\n\n" +
                "Plan: " + months + " month(s)\n" +
                "Valid till: " + formatDate(newExpiry)
            );

            return;
        }
    }

    send(ADMIN_CHAT_ID, "Chat ID not found.");
}

function onDeactivate(text) {
    const parts = text.trim().split(/\s+/);
    if (parts.length < 2) return;

    const chatId = parts[1];
    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    for (let i = 1; i < rows.length; i++) {
        if (String(rows[i][COL.telegram_chat_id]) === chatId) {

            // HARD RESET
            sheet.getRange(i + 1, 3).setValue(new Date());
            sheet.getRange(i + 1, 4).setValue("live");
            sheet.getRange(i + 1, 5).setValue(0);

            send(chatId, "‚õî <b>Your subscription has been moved to LIVE</b>");

            send(
                ADMIN_CHAT_ID,
                "‚õî Deactivated " + chatId +
                " | months=0 | instruments cleared"
            );
            return;
        }
    }

    send(ADMIN_CHAT_ID, "‚ùå Chat ID not found: " + chatId);
}

function activateAuthUser(email, months) {

    const sheet = SpreadsheetApp
        .openById(SPREADSHEET_ID)
        .getSheetByName("USERS_AUTH");

    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    for (let i = 1; i < rows.length; i++) {

        if (String(rows[i][0]).toLowerCase() !== email.toLowerCase()) continue;

        const currentExpiry = new Date(rows[i][2]);
        const currentPlan = String(rows[i][3]).toLowerCase();

        let baseDate =
            (currentPlan === "live+" && currentExpiry > now) ?
            currentExpiry :
            now;

        const newExpiry = new Date(baseDate);
        newExpiry.setMonth(newExpiry.getMonth() + months);

        sheet.getRange(i + 1, 3).setValue(newExpiry); // expiry
        sheet.getRange(i + 1, 4).setValue("live+"); // plan
        sheet.getRange(i + 1, 5).setValue(months); // plan_months

        return;
    }
}

function activateAndroidPurchase(email, purchaseToken, months) {

    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    email = String(email).toLowerCase().trim();

    for (let i = 1; i < rows.length; i++) {

        const rowEmail = String(rows[i][COL.email] || "").toLowerCase().trim();
        if (rowEmail !== email) continue;

        const currentExpiry = rows[i][COL.expiry] ?
            new Date(rows[i][COL.expiry]) :
            new Date(0);

        const currentPlan = String(rows[i][COL.plan] || "").toLowerCase();

        let baseDate = now;

        if (currentPlan === "live+" && currentExpiry > now) {
            baseDate = currentExpiry;
        }

        const newExpiry = new Date(baseDate);
        newExpiry.setMonth(newExpiry.getMonth() + months);

        sheet.getRange(i + 1, COL.expiry + 1).setValue(newExpiry);
        sheet.getRange(i + 1, COL.plan + 1).setValue("live+");
        sheet.getRange(i + 1, COL.plan_months + 1).setValue(months);
        sheet.getRange(i + 1, COL.play_purchase_token + 1).setValue(purchaseToken);
        sheet.getRange(i + 1, COL.platform + 1).setValue("android");

        return {
            success: true,
            expiry: newExpiry
        };
    }

    // ‚ùå If no row exists ‚Üí DO NOT create one
    return {
        success: false,
        error: "user_not_found"
    };
}

function onBroadcast(text) {
    const msg = text.replace("/sendall", "").trim();
    if (!msg) return;

    const rows = mustGetSheet().getDataRange().getValues();

    for (let i = 1; i < rows.length; i++) {
        const chatId = String(rows[i][6] || "");
        if (!chatId) continue;
        send(chatId, "üì¢ <b>Announcement</b>\n\n" + msg);
    }

    send(ADMIN_CHAT_ID, "‚úÖ Broadcast sent");
}

function onAdminReply(text) {
    const parts = text.split(" ");
    if (parts.length < 3) return;

    const chatId = parts[1];
    const msg = parts.slice(2).join(" ");

    send(chatId, "üí¨ <b>Support</b>\n\n" + msg);
    send(ADMIN_CHAT_ID, "‚úÖ Reply sent to " + chatId);
}

function updateMarketNotes(text) {

    // EXPECTED FORMAT:
    // XAUUSD|Your 120 word commentary here...

    const idx = text.indexOf("|")
    if (idx === -1) return

    const pair = text.substring(0, idx).toUpperCase()
    const note = text.substring(idx + 1)

    if (PAIRS.indexOf(pair) === -1) return

    const notes = getMarketNotes()
    notes[pair] = note

    setMarketNotes(notes)
    // ALSO WRITE TO UPDATES_FEED SHEET
    const feedSheet = SpreadsheetApp
        .openById(SPREADSHEET_ID)
        .getSheetByName("UPDATES_FEED");

    feedSheet.appendRow([
        new Date().toISOString(),
        pair,
        note,
        "", // no image
        "AI"
    ]);

    pruneUpdatesFeed(feedSheet);
}

// ======================================================
// CALLBACK HANDLER
// ======================================================
function handleCallback(cq) {
    const chatId = String(cq.message.chat.id);
    answerCallback(cq.id);
    const cache = CacheService.getScriptCache();

    if (cq.data === "paid_confirm") {
        if (cache.get("paid_" + chatId)) return;
        cache.put("paid_" + chatId, "1", 3600);

        send(ADMIN_CHAT_ID, "üí≥ Payment confirmation\nChat ID: <code>" + chatId + "</code>");
        sendRich(chatId,
            "‚úÖ <b>Payment confirmation query received</b>\n\nYour subscription will be activated shortly.",
            null
        );
        return;
    }

    if (cq.data.startsWith("support_")) {
        send(ADMIN_CHAT_ID,
            "üÜò Support request\nType: " + cq.data + "\nChat ID: " + chatId
        );
        sendRich(chatId,
            "‚úÖ <b>Support request sent</b>\n\nOur team will review and respond if needed.",
            null
        );
    }

    if (cq.data.startsWith("inst_tmp_")) {

        const inst = cq.data.replace("inst_tmp_", "");
        let list = getTempInstruments(chatId) || [];

        if (list.indexOf(inst) !== -1) {
            list = list.filter(x => x !== inst);
        } else {
            list.push(inst);
        }

        setTempInstruments(chatId, list);

        editInstrumentPanel(chatId, cq.message.message_id, list);
        return;
    }

    if (cq.data === "inst_confirm") {

        const list = getTempInstruments(chatId) || [];
        saveInstrumentsToSheet(chatId, list);
        clearTempInstruments(chatId);

        editFinalInstrumentMessage(
            chatId,
            cq.message.message_id,
            list
        );
        return;
    }

    if (cq.data === "inst_cancel") {
        clearTempInstruments(chatId);

        const payload = {
            chat_id: chatId,
            message_id: cq.message.message_id,
            text: "‚ùå <b>Selection cancelled</b>",
            parse_mode: "HTML"
        };

        UrlFetchApp.fetch(
            "https://api.telegram.org/bot" + TOKEN + "/editMessageText", {
                method: "post",
                contentType: "application/json",
                payload: JSON.stringify(payload)
            }
        );
        return;
    }

}

function getUserInstruments(chatId) {

    const rows = mustGetSheet().getDataRange().getValues();

    for (let i = 1; i < rows.length; i++) {

        if (String(rows[i][COL.telegram_chat_id]) === chatId) {

            const v = rows[i][5]; // Column F instruments
            return v ? String(v).split(",") : [];
        }
    }

    return [];
}

function editInstrumentPanel(chatId, messageId, selected) {

    const payload = {
        chat_id: chatId,
        message_id: messageId,
        text: "üìå <b>Select Trading Instruments</b>\n\nToggle pairs then press Confirm.",
        parse_mode: "HTML",
        reply_markup: buildInstrumentKeyboard(selected)
    };

    UrlFetchApp.fetch(
        "https://api.telegram.org/bot" + TOKEN + "/editMessageText", {
            method: "post",
            contentType: "application/json",
            payload: JSON.stringify(payload)
        }
    );
}

function getTempInstruments(chatId) {
    const cache = CacheService.getScriptCache();
    const raw = cache.get("inst_tmp_" + chatId);
    if (!raw) return null;
    return raw.split(",");
}

function setTempInstruments(chatId, list) {
    const cache = CacheService.getScriptCache();
    cache.put("inst_tmp_" + chatId, list.join(","), 600); // 10 minutes
}

function clearTempInstruments(chatId) {
    const cache = CacheService.getScriptCache();
    cache.remove("inst_tmp_" + chatId);
}

function saveInstrumentsToSheet(chatId, list) {

    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();

    for (let i = 1; i < rows.length; i++) {

        if (String(rows[i][COL.telegram_chat_id]) === chatId) {

            sheet.getRange(i + 1, 6).setValue(list.join(",")); // Column F
            return;
        }
    }
}

function editFinalInstrumentMessage(chatId, messageId, list) {

    const payload = {
        chat_id: chatId,
        message_id: messageId,
        text: "‚úÖ <b>Saved</b>\n\nYou will receive alerts only for:\n<b>" +
            (list.length ? list.join(", ") : "None") +
            "</b>",
        parse_mode: "HTML"
    };

    UrlFetchApp.fetch(
        "https://api.telegram.org/bot" + TOKEN + "/editMessageText", {
            method: "post",
            contentType: "application/json",
            payload: JSON.stringify(payload)
        }
    );
}

// ======================================================
// START / MENU / CORE UI (UNCHANGED)
// ======================================================
function onStart(chatId) {

    const row = getUserRow(chatId);

    if (!row) {

        sendRich(
            chatId,
            "üëã <b>Welcome to FXHEDZ LIVE</b>\n\n" +
            "To activate access:\n\n" +
            "1Ô∏è‚É£ Login inside the FXHEDZ app\n" +
            "2Ô∏è‚É£ Upgrade to LIVE+ anytime\n" +
            "3Ô∏è‚É£ Link this Telegram Chat ID\n\n" +
            "üÜî Your Chat ID:\n<code>" + chatId + "</code>\n\n" +
            "Open the app to continue.",
            null
        );

        return;
    }

    const now = new Date();

    const active =
        row.plan === "live" || row.plan === "live+";

    if (!active) {
        sendExpired(chatId);
        return;
    }

    let planLine;

    if (row.plan === "live+") {
        planLine =
            "Plan: LIVE+\n" +
            "Valid till: " + formatDate(row.expiry);
    } else {
        planLine =
            "Plan: LIVE\n" +
            "Base access active";
    }

    sendMenu(
        chatId,
        "üëã <b>Welcome back</b> " + chatId + "\n\n" +
        planLine
    );
}

function sendMenu(chatId, text) {
    sendRich(chatId, text, getMainKeyboard());
}

function onPlan(chatId) {

    if (!isUserAllowed(chatId)) {
        sendExpired(chatId);
        return;
    }

    const row = getUserRow(chatId);

    let text;

    if (row.plan === "live+") {
        text =
            "üìä <b>Subscription Plan</b>\n\n" +
            "Plan: LIVE+\n" +
            "Valid till: " + formatDate(row.expiry);
    } else {
        text =
            "üìä <b>Subscription Plan</b>\n\n" +
            "Plan: LIVE\n" +
            "Base access active";
    }

    sendMenu(chatId, text);
}

function onMyId(chatId) {
    sendRich(
        chatId,
        "üÜî <b>Your Telegram Chat ID</b>\n\n" +
        "<code>" + chatId + "</code>\n\n" +
        "This ID is used internally for subscription management.",
        null
    );
}

function onSubscription(chatId) {

    const row = getUserRow(chatId);

    let planText;

    if (!row) {

        planText =
            "Plan: LIVE\n" +
            "Base access active\n" +
            "Includes: ETHUSD, USDCHF";

    } else if (row.plan === "live+") {

        planText =
            "Plan: LIVE+\n" +
            "Valid till: " + formatDate(row.expiry);

    } else if (row.plan === "live") {

        planText =
            "Plan: LIVE\n" +
            "Base access active\n" +
            "Includes: ETHUSD, USDCHF";

    } else {

        // Any unexpected state
        planText =
            "Plan: LIVE\n" +
            "Base access active";
    }

    sendRich(
        chatId,
        "üí≥ <b>FXHEDZ LIVE+</b>\n\n" +
        planText + "\n\n" +
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n" +
        "Upgrade to LIVE+ üëá\n\n" +
        "üî• <b>6 Months</b> is most popular\n" +
        "üíé <b>12 Months</b> is best value\n\n" +
        "üÜî <b>Chat ID</b>: " +
        "<code>" + chatId + "</code>\n\n" +
        "‚ö†Ô∏è <b>IMPORTANT</b>\n" +
        "Add your Chat ID in Razorpay payment notes", {
            inline_keyboard: [
                [{
                    text: "LIVE+ ¬∑ $9.99 / month",
                    url: "https://rzp.io/l/fxhedz_monthly"
                }],
                [{
                    text: "‚úÖ I Have Paid",
                    callback_data: "paid_confirm"
                }]
            ]
        }
    );
}

function onSupport(chatId) {
    sendRich(
        chatId,
        "üÜò <b>Support</b>\n\n" +
        "If you need assistance, please choose one option below.\n\n" +
        "‚ö†Ô∏è For faster resolution, avoid sending messages directly.", {
            inline_keyboard: [
                [{
                    text: "üí≥ Payment Issue",
                    callback_data: "support_payment"
                }],
                [{
                    text: "‚õî Access / Subscription Issue",
                    callback_data: "support_access"
                }],
                [{
                    text: "‚ùì General Query",
                    callback_data: "support_general"
                }]
            ]
        }
    );
}

function onBooks(chatId) {

    sendRich(
        chatId,
        "üìö <b>FXHEDZ Forex Trilogy (3 book series)</b>\n\n" +
        "Explore the official trilogy on Amazon:\n\n" +
        "üìò The Foundation of Forex Trading\n" +
        "üìô The Psychology of Forex Trading\n" +
        "üìó The Strategy of Forex Trading\n\n" +
        "Tap below to view:", {
            inline_keyboard: [
                [{
                    text: "üìö View on Amazon",
                    url: "https://www.amazon.com/dp/B0FQ11LS2Q?tag=global"
                }]
            ]
        }
    );
}

function isUserAllowed(chatId) {
    const row = getUserRow(chatId);
    if (!row) return false;

    const now = new Date();

    return row.plan === "live" || row.plan === "live+";
}

function sendExpired(chatId) {
    sendMenu(
        chatId,
        "‚õî <b>Access Restricted</b>\n\n" +
        "Please contact support if this is unexpected."
    );
}

function stripMachineHeader(text) {

    const lines = text.split("\n");

    if (!lines.length) return text;

    const parts = lines[0].split("|");

    // üî• remove ANY machine header >=5 segments
    if (parts.length >= 5) {
        lines.shift();
    }

    return lines.join("\n").trim();
}

// ======================================================
// SIGNAL BROADCAST
// ======================================================
function handleSignal(msg, tx) {
    msg = msg.trim()
        .replace(/^\/alert\b/i, "")
        .replace(/^\/ALERT\b/i, "")
        .trim();
    const cache = CacheService.getScriptCache();
    const signals = getLiveSignals();
    if (msg.startsWith("/history")) {
        handleHistory(msg.replace("/history", "").trim());
        return;
    }
    const firstLine = msg.split("\n")[0];
    // =========================
    // üî• MT5 LIVE CANDLE STREAM (50 candles)
    // =========================
    if (firstLine.startsWith("/tick")) {

        const clean = firstLine.replace("/tick", "").trim();
        const p = clean.split("|");

        const instrument = (p[0] || "").toUpperCase().trim();
        const price = p[1] || "0";

        if (PAIRS.indexOf(instrument) === -1) return;

        let positionsRaw = "";
        let candlesRaw = "";

        if (p.length === 4) {
            positionsRaw = p[2] || "";
            candlesRaw = p[3] || "";
        } else if (p.length === 3) {
            // no positions, only candles
            candlesRaw = p[2] || "";
        }

        // --------------------------
        // Parse positions
        // --------------------------
        let liveOrders = [];

        if (positionsRaw) {

            const list = positionsRaw.split(";").filter(Boolean);

            list.forEach(row => {

                const o = row.split(",");
                if (o.length < 3) return;

                const rowSymbol = (o[0] || "").toUpperCase().trim();
                if (rowSymbol !== instrument) return;

                liveOrders.push({
                    id: Utilities.getUuid(),
                    label: "",
                    direction: "",
                    entry: 0,
                    lots: Number(o[1] || 0),
                    profit: Number(o[2] || 0),
                    time: Utilities.formatDate(new Date(), "GMT", "HH:mm:ss")
                });
            });
        }

        // --------------------------
        // Parse candles
        // --------------------------
        let candles = [];

        if (candlesRaw) {

            const list = candlesRaw.split(";");

            list.forEach(row => {

                const c = row.split(",");
                if (c.length < 5) return;

                candles.push({
                    time: Number(c[0]),
                    open: Number(c[1]),
                    high: Number(c[2]),
                    low: Number(c[3]),
                    close: Number(c[4])
                });
            });
        }

        const prevOrders = signals[instrument]?.orders || [];

        const updatedOrders = prevOrders.map((order, index) => {
            const live = liveOrders[index];
            return {
                ...order,
                profit: live ? live.profit : order.profit
            };
        });

        const updated = {
            ...signals,
            [instrument]: {
                ...(signals[instrument] || {}),
                price: price,
                candles: candles,
                orders: updatedOrders
            }
        };

        setLiveSignals(updated);
        return;

    }

    if (firstLine.indexOf("|") !== -1) {

        const parts = firstLine.split("|");
        const ordersField = parts[10] || "";
        const posLots = Number(parts[8] || 0);

        const sideField = parts[9] || "";
        const orderSide = sideField.replace("SIDE=", "");

        const instrument = (parts[0] || "").toUpperCase().trim();
        if (PAIRS.indexOf(instrument) === -1) return;

        const direction = parts[1].replace(/<[^>]*>/g, "");
        const entry = parts[2];
        const sl = parts[3];
        const tp = parts[4];
        const lots = parts[5];
        const buys = parts[6];
        const sells = parts[7];
        // keep previous orders
        const prevOrders = (signals[instrument]?.orders || []).slice()
        let profit = 0;

        let parsedOrders = [];

        if (ordersField.startsWith("ORDERS=")) {

            const raw = ordersField.replace("ORDERS=", "");
            const list = raw.split(";").filter(Boolean);

            parsedOrders = list.map(row => {

                const o = row.split(",");

                return {
                    label: o[0],
                    entry: o[1],
                    lots: Number(o[2] || 0),
                    profit: Number(o[3] || 0)
                };
            });
        }

        let newOrders = prevOrders

        if (direction === "EXIT") {

            // EXIT clears all
            newOrders = []

        } else {

            const rawDir = parts[1].toUpperCase()

            let orderDirection = rawDir
            let hedged = false

            if (rawDir === "HEDGED") {

                hedged = true

                // üî• get LAST REAL ORDER SIDE
                const lastOrder =
                    prevOrders.length ?
                    prevOrders[prevOrders.length - 1] :
                    null

                if (lastOrder && lastOrder.direction) {

                    // hedge = opposite of last order
                    orderDirection =
                        lastOrder.direction === "BUY" ?
                        "SELL" :
                        "BUY"

                } else {

                    // fallback safety
                    orderDirection = "BUY"
                }
            }

            newOrders = parsedOrders.map(o => ({
                id: Utilities.getUuid(),
                label: o.label,
                direction: o.label.startsWith("B") ? "BUY" : "SELL",
                hedged: direction === "HEDGED",
                entry: o.entry,
                lots: o.lots,
                profit: o.profit,
                time: Utilities.formatDate(new Date(), "GMT", "HH:mm:ss")
            }));

        }

        const updated = {
            ...signals,
            [instrument]: {
                ...(signals[instrument] || {}),
                direction: direction,
                entry: direction === "EXIT" ? null : entry,
                sl: direction === "EXIT" ? null : sl,
                tp: direction === "EXIT" ? null : tp,
                price: entry,
                lots: Number(lots || 0),
                buys: Number(buys || 0),
                sells: Number(sells || 0),
                orders: newOrders
            }
        };

        setLiveSignals(updated);

        if (tx && instrument) {

            // small delay ensures cache visible to parallel execution
            Utilities.sleep(150);

            cache.put(
                "tx_" + tx,
                JSON.stringify({
                    instrument: instrument,
                    text: stripMachineHeader(msg)
                }),
                120 // longer TTL
            );
        }
        return;
    }

    const text = msg.toUpperCase();
    const parts = text.split(/\s+/);

    const instrument = parts[0] || null;
    const direction = (parts[1] || "").replace(/<[^>]*>/g, "");

    // =========================
    // üî• PRICE UPDATE ENGINE
    // =========================
    // Handles messages like:
    // BTCUSD 49721.3
    if (parts.length === 2 && !(direction || "").match(/BUY|SELL|EXIT/)) {

        const price = parts[1];

        if (signals[instrument]) {

            const updated = {
                ...signals,
                [instrument]: {
                    ...(signals[instrument] || {}),
                    price: price
                }
            };

            setLiveSignals(updated);
        }

        return; // üö® IMPORTANT ‚Äî stop here
    }

    // =========================
    // üî• ALERT PARSER
    // =========================

    const slMatch = text.match(/SL(?:\/HEDZ)?[:\s]+([\d\.]+)/);
    const tpMatch = text.match(/TP(?:\d)?[:\s]+([\d\.]+)/);
    const entryMatch =
        text.match(/PRICE[:\s]+([\d\.]+)/) ||
        text.match(/PRICE<\/B>[:\s]*([\d\.]+)/i) ||
        text.match(/<B>PRICE:<\/B>\s*([\d\.]+)/i);

    const sl = slMatch ? slMatch[1] : null;
    const tp = tpMatch ? tpMatch[1] : null;
    const entry = entryMatch ? entryMatch[1] : null;

    if (instrument && direction) {

        const updated = {
            ...signals,
            [instrument]: {
                ...(signals[instrument] || {}),
                direction: direction,
                entry: entry || signals[instrument]?.entry,
                sl: direction === "HEDGED" ? null : sl,
                tp: direction === "HEDGED" ? null : tp,
                price: entry || signals[instrument]?.price,
                trend: "H1 Trend Strong"
            }
        };

        setLiveSignals(updated);

    }

    if (tx) {
        cache.put(
            "tx_" + tx,
            JSON.stringify({
                instrument: instrument,
                text: stripMachineHeader(msg)
            }),
            60
        );
    }
}

function handleHistory(text) {

    const parts = text.split(/\s+/)

    // EXPECTED:
    // XAUUSD SELL 4996.4 4956.7 -124.3 2026-02-13T10:22

    const instrument = (parts[0] || "").toUpperCase()
    const direction = (parts[1] || "").toUpperCase()

    if (PAIRS.indexOf(instrument) === -1) return
    if (["BUY", "SELL"].indexOf(direction) === -1) return

    const entry = parts[2]
    const exit = parts[3]
    const pnl = parts[4]
    const time = parts[5] || Utilities.formatDate(new Date(), "GMT", "yyyy-MM-dd'T'HH:mm")

    if (!instrument || !entry || !exit) return

    const cache = CacheService.getScriptCache()
    const hash = instrument + "|" + entry + "|" + exit + "|" + time

    // üî• duplicate protection
    if (cache.get(hash)) return
    cache.put(hash, "1", 30)

    // ‚úÖ WRITE TO GOOGLE SHEET (MASTER HISTORY)
    appendHistoryRow(instrument, direction, entry, exit, pnl, time)

    // OPTIONAL: keep small live cache for miniapp speed
    const history = getOrderHistory()

    if (!history[instrument]) history[instrument] = []

    history[instrument].unshift({
        direction,
        entry,
        exit,
        pnl: Number(pnl),
        time
    })

    history[instrument] = history[instrument].slice(0, 50)

    setOrderHistory(history)

    // ==============================
    // üî• LIVE PERFORMANCE UPDATE
    // ==============================

    const perfCache = getPairPerformanceCache()

    if (!perfCache[instrument]) {
        perfCache[instrument] = {
            trades: 0,
            wins: 0,
            losses: 0,
            pnlTotal: 0,
            profit: 0,
            loss: 0
        }
    }

    const p = perfCache[instrument]
    const pnlNum = Number(pnl) || 0

    p.trades++
    p.pnlTotal += pnlNum

    if (pnlNum >= 0) {
        p.wins++
        p.profit += pnlNum
    } else {
        p.losses++
        p.loss += Math.abs(pnlNum)
    }

    p.winRate = p.trades ? (p.wins / p.trades) * 100 : 0
    p.profitFactor = p.loss ? (p.profit / p.loss) : p.profit

    setPairPerformanceCache(perfCache)

}

function getPairDataFromSheet(pair) {

    const sheet = SpreadsheetApp
        .openById(SPREADSHEET_ID)
        .getSheetByName("ORDER_HISTORY")

    const lastRow = sheet.getLastRow()
    if (lastRow < 2) {
        return {
            history: [],
            performance: {}
        }
    }

    const rows = sheet.getRange(1, 1, lastRow, 6).getValues()

    const history = []

    let wins = 0,
        losses = 0,
        pnlTotal = 0,
        profit = 0,
        loss = 0,
        trades = 0

    for (let i = rows.length - 1; i >= 1; i--) {

        if (rows[i][1] !== pair) continue

        const pnl = Number(rows[i][5]) || 0

        // ===== history (latest 100)
        if (history.length < 100) {
            history.push({
                time: rows[i][0],
                direction: rows[i][2],
                entry: rows[i][3],
                exit: rows[i][4],
                pnl: pnl
            })
        }

        // ===== performance
        pnlTotal += pnl
        trades++

        if (pnl >= 0) {
            wins++
            profit += pnl
        } else {
            losses++
            loss += Math.abs(pnl)
        }
    }

    const winRate = trades ? (wins / trades) * 100 : 0
    const profitFactor = loss ? (profit / loss) : profit

    return {
        history,
        performance: {
            trades,
            wins,
            losses,
            winRate: Number(winRate.toFixed(1)),
            pnlTotal: Number(pnlTotal.toFixed(2)),
            profitFactor: Number(profitFactor.toFixed(2))
        }
    }
}

// ======================================================
// IMAGE BROADCAST
// ======================================================
function dispatchImageToUsers(blob, tx) {

    const cache = CacheService.getScriptCache();
    let payload = null;

    // =========================================
    // RETRIEVE CACHED TEXT (PAIRING WITH IMAGE)
    // =========================================
    if (tx) {

        for (let i = 0; i < 5; i++) {

            const raw = cache.get("tx_" + tx);

            if (raw) {
                payload = JSON.parse(raw);
                break;
            }

            Utilities.sleep(250);
        }
    }

    const instrument = payload ? payload.instrument : null;

    // =========================================
    // UPDATE MINIAPP STATE
    // =========================================
    if (payload && payload.text) {

        handleSignal(payload.text, null);

        const parts = payload.text.trim().split(/\s+/);
        const direction = parts.length > 1 ?
            parts[1].toUpperCase().replace(/<[^>]*>/g, "") :
            null;

        if (instrument && direction) {

            const signals = getLiveSignals();

            const updated = {
                ...signals,
                [instrument]: {
                    ...(signals[instrument] || {}),
                    direction: direction,
                    trend: "H1 Trend Strong"
                }
            };

            setLiveSignals(updated);
        }
    }

    const caption = payload ?
        stripMachineHeader(payload.text) :
        "üìä FXHEDZ Chart Snapshot";

    // =========================================
    // SAVE IMAGE TO GOOGLE DRIVE
    // =========================================
    const folder = DriveApp.getFolderById("1wQSnKddV3nT3UoBoeXedZSu_JXHZKp5m");

    const file = folder.createFile(blob);
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);

    const imageUrl = file.getId();

    // =========================================
    // WRITE TO UPDATES_FEED SHEET
    // =========================================
    if (instrument) {

        const feedSheet = SpreadsheetApp
            .openById(SPREADSHEET_ID)
            .getSheetByName("UPDATES_FEED");

        feedSheet.appendRow([
            new Date().toISOString(), // A time
            instrument, // B pair
            caption, // C text
            imageUrl, // D image
            "MT5" // E source
        ]);

    }

    // =========================================
    // MULTI-CHANNEL DISTRIBUTION (ISOLATED)
    // =========================================

    const rows = mustGetSheet().getDataRange().getValues();

    for (let i = 1; i < rows.length; i++) {

        const plan = String(rows[i][COL.plan] || "").toLowerCase();

        // -------------------------------------
        // PLAN CHECK
        // -------------------------------------
        if (plan !== "live" && plan !== "live+") continue;

        let allowedPairs = plan === "live" ? ["ETHUSD", "USDCHF"] :
            PAIRS;

        if (!instrument || allowedPairs.indexOf(instrument) === -1)
            continue;

        // =====================================
        // TELEGRAM CHANNEL
        // =====================================
        const chatId = String(rows[i][COL.telegram_chat_id] || "");
        const tgSelected = rows[i][COL.telegram_pairs] ?
            String(rows[i][COL.telegram_pairs]).split(",").filter(Boolean) : [];

        if (chatId && tgSelected.indexOf(instrument) !== -1) {

            UrlFetchApp.fetch(
                "https://api.telegram.org/bot" + TOKEN + "/sendPhoto", {
                    method: "post",
                    payload: {
                        chat_id: chatId,
                        photo: blob,
                        caption: caption,
                        parse_mode: "HTML"
                    },
                    muteHttpExceptions: true
                }
            );
        }

        // =====================================
        // ANDROID CHANNEL
        // =====================================
        const androidSelected = rows[i][COL.android_pairs] ?
            String(rows[i][COL.android_pairs]).split(",").filter(Boolean) : [];

        const pushToken = rows[i][COL.android_push_token] || "";

        if (pushToken && androidSelected.indexOf(instrument) !== -1) {
            sendPush(pushToken, instrument, caption);
        }

        // =====================================
        // WEB CHANNEL
        // =====================================
        const webSelected = rows[i][COL.web_pairs] ?
            String(rows[i][COL.web_pairs]).split(",").filter(Boolean) : [];

        const webPushToken = rows[i][COL.web_push_token] || "";

        if (webPushToken && webSelected.indexOf(instrument) !== -1) {
            sendWebPush(webPushToken, instrument, caption);
        }
    }

    // =========================================
    // PRUNE AFTER TELEGRAM SEND
    // =========================================
    if (instrument) {

        const feedSheet = SpreadsheetApp
            .openById(SPREADSHEET_ID)
            .getSheetByName("UPDATES_FEED");

        pruneUpdatesFeed(feedSheet);
    }

    if (tx) {
        cache.remove("tx_" + tx);
    }
}

function sendWebPush(token, pair, text) {

    // üîí Placeholder until Web Push infra implemented
    Logger.log("WEB PUSH ‚Üí " + pair + " ‚Üí " + token);

}

function setMenuButton() {

    const url = "https://api.telegram.org/bot" + TOKEN + "/setChatMenuButton";

    const payload = {
        menu_button: {
            type: "web_app",
            text: "üö¶ Signals",
            web_app: {
                url: "https://fxhedz.vercel.app/"
            }
        }
    };

    UrlFetchApp.fetch(url, {
        method: "post",
        contentType: "application/json",
        payload: JSON.stringify(payload)
    });
}

// ======================================================
// UTILITIES (UNCHANGED)
// ======================================================
function getMainKeyboard() {
    return {
        keyboard: [
            [{
                    text: "üí± PAIR"
                },
                {
                    text: "üëë LIVE+"
                },
                {
                    text: "üìö READ"
                },
                {
                    text: "üÜò HELP"
                }
            ]
        ],
        resize_keyboard: true,
        is_persistent: true,
        one_time_keyboard: false
    };
}

function debugSignals() {
    const raw = PropertiesService.getScriptProperties().getProperty("LIVE_SIGNALS");
    Logger.log(raw);
}

function getUserRow(chatId) {

    const rows = mustGetSheet().getDataRange().getValues();

    for (let i = 1; i < rows.length; i++) {

        if (String(rows[i][COL.telegram_chat_id]) === chatId) {

            return {
                rowIndex: i + 1,
                email: rows[i][0],
                expiry: rows[i][2] ? new Date(rows[i][2]) : new Date(0),
                plan: String(rows[i][3] || "").toLowerCase(),
                plan_months: rows[i][4] || 0,
                instruments: rows[i][5] ? String(rows[i][5]).split(",") : []
            };
        }
    }

    return null;
}

function pruneUpdatesFeed(sheet) {

    const maxRows = 20000; // ~3 months heavy usage
    const currentRows = sheet.getLastRow();

    if (currentRows <= maxRows) return;

    const rowsToDelete = 500;

    sheet.deleteRows(2, rowsToDelete);
}

function send(chatId, text) {
    sendRich(chatId, text, null);
}

function sendPush(token, pair, text) {

    UrlFetchApp.fetch("https://exp.host/--/api/v2/push/send", {
        method: "post",
        contentType: "application/json",
        payload: JSON.stringify({
            to: token,
            sound: "default",
            title: "FXHEDZ " + pair,
            body: text.substring(0, 150),
            data: {
                pair: pair
            }
        }),
        muteHttpExceptions: true
    });
}

function sendRich(chatId, text, markup) {
    const payload = {
        chat_id: chatId,
        text,
        parse_mode: "HTML",
        reply_markup: markup ? markup : getMainKeyboard()
    };

    UrlFetchApp.fetch(
        "https://api.telegram.org/bot" + TOKEN + "/sendMessage", {
            method: "post",
            contentType: "application/json",
            payload: JSON.stringify(payload),
            muteHttpExceptions: true
        }
    );
}

function answerCallback(id) {
    UrlFetchApp.fetch(
        "https://api.telegram.org/bot" + TOKEN + "/answerCallbackQuery", {
            method: "post",
            contentType: "application/json",
            payload: JSON.stringify({
                callback_query_id: id
            })
        }
    );
}

function formatDate(d) {
    return Utilities.formatDate(new Date(d), "GMT+5:30", "dd MMM yyyy");
}

function ok() {
    return HtmlService.createHtmlOutput("OK");
}

// RUN ONCE DAILY
function nightlyExpirySweep() {

    const sheet = mustGetSheet();
    const rows = sheet.getDataRange().getValues();
    const now = new Date();

    for (let i = 1; i < rows.length; i++) {

        const expiry = rows[i][2] ? new Date(rows[i][2]) : new Date(0);
        const plan = String(rows[i][COL.plan] || "").toLowerCase();

        if (plan === "live+" && expiry < now) {

            // downgrade to base tier
            sheet.getRange(i + 1, 4).setValue("live");
            sheet.getRange(i + 1, 5).setValue(0); // reset plan_months
        }
    }
}

// RUN ONLY WHEN DEPLOYMENT URL CHANGES
function resetAndSetWebhook() {
    const TOKEN = PropertiesService.getScriptProperties().getProperty("BOT_TOKEN");
    const WEBHOOK_URL = "https://script.google.com/macros/s/AKfycby55ye_dTtWJ-QILNYJIaXWv74_n7n0muh3U--sBl7yowMlp1FzESOokWqeHI75U5_R/exec";
    const base = "https://api.telegram.org/bot" + TOKEN;

    UrlFetchApp.fetch(base + "/deleteWebhook", {
        method: "post",
        contentType: "application/json",
        payload: JSON.stringify({
            drop_pending_updates: true
        })
    });

    Utilities.sleep(3000);

    UrlFetchApp.fetch(base + "/setWebhook", {
        method: "post",
        contentType: "application/json",
        payload: JSON.stringify({
            url: WEBHOOK_URL
        })
    });
}